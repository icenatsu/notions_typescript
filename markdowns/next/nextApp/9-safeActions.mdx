---
title: Les Safe Actions
description: Probl√®mes li√©s au server Action
---

## Pas TypeSafe

Tous les param√®tres que l'on d√©finit pour nos Server Actions avec TypeScript ne sont pas du tout garantis.
Il faut donc faire attention √† ce que l'on envoie et √† ce que l'on re√ßoit.

<Pre>
```tsx
"use server"

export const myAction = (
  someParams: { id: string } // Peut √™tre une string, un number ou n'importe quoi ‚ö†Ô∏è üëá
) => {
  // ...
}
```
</Pre>

## Gestion d'erreur compliqu√©e

Quand on throw erreur on va faire crasher nos servers actions :

- on ne pourra pas r√©monter l'information au client => erreur g√©n√©rique 500

<Pre>
```tsx
"use server"

export const myAction = (id: string) => {
  if (typeof id !== "string") {
    throw new Error("Your id must be a string")
  }

  if (id === "") {
    throw new Error("Your id must NOT be empty.")
  }

  return "ok"
}

// oblige √† faire ceci :

"use server"

export const myAction = (id: string) => {
  if (typeof id !== "string") {
    return {
      ok: false,
      error: "Your id must be a string"
    }
  }

  if (id === "") {
    return {
      ok: false,
      error: "Your id must NOT be empty."
    }
  }

  return {
    ok: true,
    data: "ok"
  }
}
```
</Pre>

## Middleware

Parfois, on veut souvent savoir quel utilisateur est en train de faire une action avant de laisser l'utilisateur la faire.
En l'occurrence, on doit constamment faire la m√™me chose d√®s que l'on veut v√©rifier que l'utilisateur est connect√© :

<Pre>
```tsx
export const someAction = () => {
  const session = await getAuthSession();

  const userId = session?.user.id;

  if (!userId) {
    throw new Error("You're not logged in. Please log in to continue.");
  }

  // ...
}
```
</Pre>

Pour r√©soudre tous les probl√®mes pr√©c√©demment vus on utilisera next-safe-action

# Next safe action

- Voir la doc: [Next-safe-action](https://next-safe-action.dev/docs/getting-started)

## Cr√©ation de l'action

<Pre>
  ```tsx title="action.ts"
  import {createSafeActionClient} from "next-safe-action"; 
  
  export const action = createSafeActionClient(); 
  ```
</Pre>

## On r√®gle le premier probl√®me : TypeSafe

Cette action prend 2 param√®tres :
  - sch√©ma
  - la fonction qui renvoie les props

<Pre>
```tsx
import { action } from "./action";

export const someAction = action(
  z.object({
    id: z.string(),
    name: z.string(),
  })
  ({ id, name }) => {
    // Si on arrive ici, c'est que id et name sont bien des strings
  }
)
```
</Pre>

Maintenant, chaque fois que notre action est appel√©e, on va pouvoir √™tre s√ªr que les param√®tres sont bien du type qu'on attend.

## On r√®gle le deuxi√®me probl√®me : La gestion des erreurs

On cr√©e notre fonction du retour d'erreur avec :
  - error.message qui correspondra au message d'erreur que l'on souhaite remonter au client
  - un message d'erreur par d√©faut  

<Pre>
```tsx
export class ActionError extends Error {}

export const action = createSafeActionClient({
  handleReturnedServerError: (error) => {
  // retourne le message d'erreur 
  if (error instanceof ActionError) {
    return error.message,
  }
  // message de retour d'erreur par d√©faut
   return 'Something went wrong!',
});
```
</Pre>

- Ensuite on pourra cr√©er notre action en g√©rant les diff√©rents messages d'erreurs qui seront remont√©s au client

<Pre>
```tsx
import { z } from 'zod';
import { ActionError, action } from './safe-action';

export const deleteUser = action(z.string(), async (userId) => {
  if (userId === 'error') {
    throw new ActionError("UserId can't be equal to error.");
  }

  if (userId === 'melvyn') {
    throw new ActionError("UserId can't be equal to melvyn !!");
  }

  return 'User is deleted.';
});
```
</Pre>

Puis dans notre client component, on va pouvoir r√©cup√©rer la serverError si elle existe pour g√©rer les cas d'erreur :

<Pre>
```tsx
'use client';

import { Button } from '@/components/ui/button';
import { deleteUser } from './next-safe-action/delete-user';
import { useState } from 'react';
import { Input } from '@/components/ui/input';

export const DeleteUserForm = () => {
  const [userId, setUserId] = useState('0');

  return (
    <div className="flex flex-wrap gap-2">
      <Input value={userId} onChange={(e) => setUserId(e.target.value)} />
      <Button
        onClick={async () => {
          const result = await deleteUser(userId);

          if (result.serverError) {
            alert('Error with message' + result.serverError);
            return;
          }



            alert('Succ√®s avec le message : ' + result.data);
        }}
      >
        Supprimer l'utilisateur
      </Button>
    </div>
  );
};
```
</Pre>

## On r√®gle le dernier probl√®me : Les middlewares

Finalement, nous voudrons souvent cr√©er des actions "uniquement pour les utilisateurs connect√©s" ou pour d'autres types d'applications "uniquement pour les administrateurs".

<Pre>
```tsx
export const authenticatedAction = createSafeActionClient({
  async middleware() {
    const session = await getAuthSession();

    const userId = session?.user.id;

    if (!userId) {
      throw new Error("Tu n'es pas connect√©. Merci de te connecter pour continuer.");
    }

    return {
      userId,
    };
  },
});
```
</Pre>

La cons√©quence est que nous allons facilement pouvoir utiliser le userId et √™tre s√ªr que celui-ci est d√©fini :

<Pre>
```tsx
export const deleteCourse = authenticatedAction(
  z.string(),
  //            üëá R√©cup√©r√© de notre middleware
  (courseId, { userId }) => {
    // v√©rification que l'utilisateur est bien le propri√©taire du cours
  }
)
```
</Pre>

